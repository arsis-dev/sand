#!/usr/bin/env python3
"""sand-synth — Générateur de sons pour sand-notify.

Usage:
    sand-synth presets                         Liste les presets disponibles
    sand-synth generate <preset> [output.aiff] Génère un son depuis un preset
    sand-synth play <preset>                   Génère + joue avec afplay
    sand-synth pack <nom>                      Génère un pack complet
"""

import argparse
import os
import subprocess
import sys
import tempfile
from pathlib import Path

# Ajouter le répertoire synth/ au path
SCRIPT_DIR = Path(os.path.realpath(__file__)).parent
SYNTH_DIR = SCRIPT_DIR.parent / 'synth'
sys.path.insert(0, str(SYNTH_DIR.parent))

from synth.engine import load_presets, render_preset, write_aiff

SOUNDS_DIR = Path.home() / '.config' / 'sand' / 'sounds'


def cmd_presets(args):
    """Liste les presets disponibles."""
    presets = load_presets()
    for name, preset in sorted(presets.items()):
        ptype = preset['type']
        dur = preset['duration']
        vol = int(preset.get('volume', 0.7) * 100)
        if ptype == 'tone':
            freq = preset['freq']
            print(f"  {name:<20} {ptype:<10} {freq}Hz  {dur}s  vol:{vol}%")
        else:
            freqs = [str(n['freq']) for n in preset['notes']]
            print(f"  {name:<20} {ptype:<10} {'+'.join(freqs)}Hz  {dur}s  vol:{vol}%")


def cmd_generate(args):
    """Génère un fichier AIFF depuis un preset."""
    presets = load_presets()
    name = args.preset

    if name not in presets:
        print(f"Preset inconnu : {name}", file=sys.stderr)
        print(f"Presets disponibles : {', '.join(sorted(presets))}", file=sys.stderr)
        sys.exit(1)

    output = args.output or f"{name}.aiff"
    signal = render_preset(name, presets[name])
    write_aiff(output, signal)
    print(f"Généré : {output}")


def cmd_play(args):
    """Génère un son temporaire et le joue avec afplay."""
    presets = load_presets()
    name = args.preset

    if name not in presets:
        print(f"Preset inconnu : {name}", file=sys.stderr)
        sys.exit(1)

    signal = render_preset(name, presets[name])
    with tempfile.NamedTemporaryFile(suffix='.aiff', delete=False) as f:
        tmpfile = f.name
    try:
        write_aiff(tmpfile, signal)
        print(f"Lecture : {name}")
        subprocess.run(['afplay', tmpfile], check=True)
    finally:
        os.unlink(tmpfile)


def cmd_pack(args):
    """Génère un pack complet de sons."""
    presets = load_presets()
    pack_name = args.name
    pack_dir = SOUNDS_DIR / pack_name

    # Trouver les presets correspondants
    stop_presets = {k: v for k, v in presets.items() if k.startswith(f"{pack_name}-stop")}
    question_presets = {k: v for k, v in presets.items() if k.startswith(f"{pack_name}-question")}

    if not stop_presets and not question_presets:
        # Fallback : chercher des presets avec le préfixe du pack
        matching = {k: v for k, v in presets.items() if k.startswith(pack_name)}
        if not matching:
            print(f"Aucun preset trouvé pour le pack '{pack_name}'", file=sys.stderr)
            print(f"Presets disponibles : {', '.join(sorted(presets))}", file=sys.stderr)
            sys.exit(1)
        # Grouper par type détecté depuis le nom
        for name, preset in matching.items():
            suffix = name[len(pack_name)+1:] if len(name) > len(pack_name) else name
            if 'stop' in suffix:
                stop_presets[name] = preset
            elif 'question' in suffix:
                question_presets[name] = preset

    # Générer les sons stop
    stop_dir = pack_dir / 'stop'
    stop_dir.mkdir(parents=True, exist_ok=True)
    for i, (name, preset) in enumerate(sorted(stop_presets.items()), 1):
        output = stop_dir / f"{name}.aiff"
        signal = render_preset(name, preset)
        write_aiff(str(output), signal)
        print(f"  stop/{name}.aiff")

    # Générer les sons question
    question_dir = pack_dir / 'question'
    question_dir.mkdir(parents=True, exist_ok=True)
    for i, (name, preset) in enumerate(sorted(question_presets.items()), 1):
        output = question_dir / f"{name}.aiff"
        signal = render_preset(name, preset)
        write_aiff(str(output), signal)
        print(f"  question/{name}.aiff")

    total = len(stop_presets) + len(question_presets)
    print(f"\nPack '{pack_name}' : {len(stop_presets)} stop, {len(question_presets)} question ({total} sons)")
    print(f"Répertoire : {pack_dir}")


def main():
    parser = argparse.ArgumentParser(
        prog='sand-synth',
        description='Générateur de sons pour sand-notify',
    )
    sub = parser.add_subparsers(dest='command')

    # presets
    sub.add_parser('presets', help='Liste les presets disponibles')

    # generate
    gen = sub.add_parser('generate', help='Génère un fichier AIFF')
    gen.add_argument('preset', help='Nom du preset')
    gen.add_argument('output', nargs='?', help='Fichier de sortie (défaut: <preset>.aiff)')

    # play
    play = sub.add_parser('play', help='Génère et joue un son')
    play.add_argument('preset', help='Nom du preset')

    # pack
    pack = sub.add_parser('pack', help='Génère un pack complet')
    pack.add_argument('name', help='Nom du pack (ex: zen)')

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(0)

    commands = {
        'presets': cmd_presets,
        'generate': cmd_generate,
        'play': cmd_play,
        'pack': cmd_pack,
    }
    commands[args.command](args)


if __name__ == '__main__':
    main()
