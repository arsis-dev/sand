#!/usr/bin/env python3
"""sand-synth â€” Sound generator for sand-notify.

Usage:
    sand-synth presets                         List available presets
    sand-synth generate <preset> [output.aiff] Generate a sound from a preset
    sand-synth play <preset>                   Generate + play with afplay
    sand-synth pack <name>                     Generate a full sound pack
"""

import argparse
import os
import subprocess
import sys
import tempfile
from pathlib import Path

# Add synth/ directory to path
SCRIPT_DIR = Path(os.path.realpath(__file__)).parent
SYNTH_DIR = SCRIPT_DIR.parent / 'synth'
sys.path.insert(0, str(SYNTH_DIR.parent))

from synth.engine import load_presets, render_preset, write_aiff

SOUNDS_DIR = Path.home() / '.config' / 'sand' / 'sounds'


def cmd_presets(args):
    """List available presets."""
    presets = load_presets()
    for name, preset in sorted(presets.items()):
        ptype = preset['type']
        dur = preset['duration']
        vol = int(preset.get('volume', 0.7) * 100)
        if ptype == 'tone':
            freq = preset['freq']
            print(f"  {name:<20} {ptype:<10} {freq}Hz  {dur}s  vol:{vol}%")
        else:
            freqs = [str(n['freq']) for n in preset['notes']]
            print(f"  {name:<20} {ptype:<10} {'+'.join(freqs)}Hz  {dur}s  vol:{vol}%")


def cmd_generate(args):
    """Generate an AIFF file from a preset."""
    presets = load_presets()
    name = args.preset

    if name not in presets:
        print(f"Unknown preset: {name}", file=sys.stderr)
        print(f"Available presets: {', '.join(sorted(presets))}", file=sys.stderr)
        sys.exit(1)

    output = args.output or f"{name}.aiff"
    signal = render_preset(name, presets[name])
    write_aiff(output, signal)
    print(f"Generated: {output}")


def cmd_play(args):
    """Generate a temporary sound and play it with afplay."""
    presets = load_presets()
    name = args.preset

    if name not in presets:
        print(f"Unknown preset: {name}", file=sys.stderr)
        sys.exit(1)

    signal = render_preset(name, presets[name])
    with tempfile.NamedTemporaryFile(suffix='.aiff', delete=False) as f:
        tmpfile = f.name
    try:
        write_aiff(tmpfile, signal)
        print(f"Playing: {name}")
        subprocess.run(['afplay', tmpfile], check=True)
    finally:
        os.unlink(tmpfile)


def cmd_pack(args):
    """Generate a full sound pack."""
    presets = load_presets()
    pack_name = args.name
    pack_dir = SOUNDS_DIR / pack_name

    # Find matching presets
    stop_presets = {k: v for k, v in presets.items() if k.startswith(f"{pack_name}-stop")}
    question_presets = {k: v for k, v in presets.items() if k.startswith(f"{pack_name}-question")}

    if not stop_presets and not question_presets:
        # Fallback: look for presets with the pack prefix
        matching = {k: v for k, v in presets.items() if k.startswith(pack_name)}
        if not matching:
            print(f"No presets found for pack '{pack_name}'", file=sys.stderr)
            print(f"Available presets: {', '.join(sorted(presets))}", file=sys.stderr)
            sys.exit(1)
        # Group by detected type from name
        for name, preset in matching.items():
            suffix = name[len(pack_name)+1:] if len(name) > len(pack_name) else name
            if 'stop' in suffix:
                stop_presets[name] = preset
            elif 'question' in suffix:
                question_presets[name] = preset

    # Generate stop sounds
    stop_dir = pack_dir / 'stop'
    stop_dir.mkdir(parents=True, exist_ok=True)
    for i, (name, preset) in enumerate(sorted(stop_presets.items()), 1):
        output = stop_dir / f"{name}.aiff"
        signal = render_preset(name, preset)
        write_aiff(str(output), signal)
        print(f"  stop/{name}.aiff")

    # Generate question sounds
    question_dir = pack_dir / 'question'
    question_dir.mkdir(parents=True, exist_ok=True)
    for i, (name, preset) in enumerate(sorted(question_presets.items()), 1):
        output = question_dir / f"{name}.aiff"
        signal = render_preset(name, preset)
        write_aiff(str(output), signal)
        print(f"  question/{name}.aiff")

    total = len(stop_presets) + len(question_presets)
    print(f"\nPack '{pack_name}': {len(stop_presets)} stop, {len(question_presets)} question ({total} sounds)")
    print(f"Directory: {pack_dir}")


def main():
    parser = argparse.ArgumentParser(
        prog='sand-synth',
        description='Sound generator for sand-notify',
    )
    sub = parser.add_subparsers(dest='command')

    # presets
    sub.add_parser('presets', help='List available presets')

    # generate
    gen = sub.add_parser('generate', help='Generate an AIFF file')
    gen.add_argument('preset', help='Preset name')
    gen.add_argument('output', nargs='?', help='Output file (default: <preset>.aiff)')

    # play
    play = sub.add_parser('play', help='Generate and play a sound')
    play.add_argument('preset', help='Preset name')

    # pack
    pack = sub.add_parser('pack', help='Generate a full sound pack')
    pack.add_argument('name', help='Pack name (e.g. zen)')

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(0)

    commands = {
        'presets': cmd_presets,
        'generate': cmd_generate,
        'play': cmd_play,
        'pack': cmd_pack,
    }
    commands[args.command](args)


if __name__ == '__main__':
    main()
