#!/usr/bin/env python3
"""sand-workspace-helper — TOML parsing and KDL generation for sand workspaces.

Called by bin/sand for:
- render  : convert a .toml to a Zellij KDL layout
- validate: check .toml syntax and paths
- migrate : convert an old plain text file to TOML
- catalog : list available TUI apps
- wizard  : generate a TOML interactively (called by sand workspace new)
"""

import argparse
import os
import shutil
import subprocess
import sys
import tomllib
from pathlib import Path

# ─── TUI apps catalog ─────────────────────────────────────────────

APPS_CATALOG = {
    "lazygit":     {"cmd": "lazygit",      "args": "",        "cat": "git",            "brew": "lazygit",     "desc": "Interactive git UI — staging, commits, branches, stash"},
    "gitui":       {"cmd": "gitui",        "args": "",        "cat": "git",            "brew": "gitui",       "desc": "Fast git TUI written in Rust"},
    "yazi":        {"cmd": "yazi",         "args": ".",       "cat": "files",          "brew": "yazi",        "desc": "Fast terminal file manager (Rust, async I/O)"},
    "broot":       {"cmd": "broot",        "args": "",        "cat": "files",          "brew": "broot",       "desc": "Tree explorer with fuzzy search"},
    "btop":        {"cmd": "btop",         "args": "",        "cat": "monitoring",     "brew": "btop",        "desc": "System monitor — CPU, memory, disks, network, processes"},
    "htop":        {"cmd": "htop",         "args": "",        "cat": "monitoring",     "brew": "htop",        "desc": "Interactive process monitor (classic)"},
    "bottom":      {"cmd": "btm",          "args": "",        "cat": "monitoring",     "brew": "bottom",      "desc": "Graphical system monitor written in Rust"},
    "lazydocker":  {"cmd": "lazydocker",   "args": "",        "cat": "docker",         "brew": "lazydocker",  "desc": "Docker dashboard — containers, images, volumes, logs"},
    "k9s":         {"cmd": "k9s",          "args": "",        "cat": "kubernetes",     "brew": "k9s",         "desc": "Kubernetes dashboard — pods, services, logs, exec"},
    "serpl":       {"cmd": "serpl",        "args": "",        "cat": "search/replace", "brew": "serpl",       "desc": "Interactive search and replace across a project"},
    "bacon":       {"cmd": "bacon",        "args": "",        "cat": "watch (rust)",   "brew": "bacon",       "desc": "Rust watcher — recompiles and shows errors/warnings live"},
    "watchexec":   {"cmd": "watchexec",    "args": "-- make", "cat": "watch",          "brew": "watchexec",   "desc": "Run a command on every file change"},
    "lnav":        {"cmd": "lnav",         "args": "",        "cat": "logs",           "brew": "lnav",        "desc": "Advanced log viewer with filtering and highlighting"},
    "posting":     {"cmd": "posting",      "args": "",        "cat": "http",           "brew": "",            "desc": "HTTP TUI client — Postman alternative in the terminal",    "install": "pipx install posting"},
    "pgcli":       {"cmd": "pgcli",        "args": "",        "cat": "database",       "brew": "pgcli",       "desc": "PostgreSQL client with autocompletion and SQL highlighting"},
    "lazysql":     {"cmd": "lazysql",      "args": "",        "cat": "database",       "brew": "",            "desc": "Multi-database SQL client (Postgres, MySQL, SQLite)",       "install": "go install github.com/jorgerojas26/lazysql@latest"},
    "shell":       {"cmd": "",             "args": "",        "cat": "terminal",       "brew": "",            "desc": "Empty terminal — plain shell session"},
}

# ─── Layout presets ──────────────────────────────────────────────────

DEFAULT_PANELS = [
    {"app": "lazygit"},
    {"app": "yazi"},
]


def _resolve_dir(dir_path, root=None):
    """Resolve a directory path (~ expansion and relative to root)."""
    d = dir_path.replace("~", str(Path.home()))
    if root and not os.path.isabs(d):
        root_expanded = root.replace("~", str(Path.home()))
        d = os.path.join(root_expanded, d)
    return os.path.normpath(d)


def _panel_to_kdl(panel, cwd, indent=4):
    """Convert a panel to a KDL pane block."""
    app = panel.get("app", "")
    command = panel.get("command", "")
    pad = " " * indent
    pad2 = " " * (indent + 4)

    if command:
        return f'{pad}pane command="bash" cwd="{cwd}" {{\n{pad2}args "-c" "{command}"\n{pad}}}'
    elif app == "shell" or (not app and not command):
        return f'{pad}pane cwd="{cwd}"'
    elif app in APPS_CATALOG:
        info = APPS_CATALOG[app]
        cmd = info["cmd"]
        args = info["args"]
        if cmd and not shutil.which(cmd):
            brew = info.get("brew", "")
            msg = f"App not found: {app}"
            if brew:
                msg += f" — brew install {brew}"
            return f'{pad}pane command="bash" cwd="{cwd}" {{\n{pad2}args "-c" "echo \\"{msg}\\"; sleep infinity"\n{pad}}}'
        if args:
            if app == "yazi":
                return f'{pad}pane command="{cmd}" cwd="{cwd}" {{\n{pad2}args "{cwd}"\n{pad}}}'
            return f'{pad}pane command="{cmd}" cwd="{cwd}" {{\n{pad2}args "{args}"\n{pad}}}'
        return f'{pad}pane command="{cmd}" cwd="{cwd}"'
    else:
        return f'{pad}pane command="{app}" cwd="{cwd}"'


def _generate_tab_kdl(tab, root=None):
    """Generate the KDL for a complete tab."""
    name = tab["name"]
    cwd = _resolve_dir(tab["dir"], root)
    layout = tab.get("layout", "default")
    panels = tab.get("panels", DEFAULT_PANELS)

    lines = [f'    tab name="{name}" cwd="{cwd}" {{']
    lines.append('        pane size=1 borderless=true {')
    lines.append('            plugin location="zellij:compact-bar"')
    lines.append('        }')

    if layout == "solo":
        lines.append(f'        pane cwd="{cwd}"')

    elif layout == "wide":
        # Terminal on top (70%), panels on bottom (30%)
        lines.append('        pane split_direction="horizontal" {')
        lines.append(f'            pane size="70%" cwd="{cwd}"')
        if panels:
            lines.append('            pane split_direction="vertical" size="30%" {')
            for p in panels:
                lines.append(_panel_to_kdl(p, cwd, indent=16))
            lines.append('            }')
        lines.append('        }')

    elif layout == "monitoring":
        # Terminal on the left (60%), stacked panels on the right (40%)
        lines.append('        pane split_direction="vertical" {')
        lines.append(f'            pane size="60%" cwd="{cwd}"')
        if panels:
            lines.append('            pane split_direction="horizontal" size="40%" {')
            for p in panels:
                lines.append(_panel_to_kdl(p, cwd, indent=16))
            lines.append('            }')
        lines.append('        }')

    else:
        # "default" — main terminal (60%) + panels (40%)
        lines.append('        pane split_direction="vertical" {')
        lines.append('            pane split_direction="horizontal" size="60%" {')
        lines.append(f'                pane size="70%" cwd="{cwd}"')
        lines.append('                pane split_direction="vertical" size="30%" {')
        lines.append(f'                    pane cwd="{cwd}"')
        lines.append(f'                    pane cwd="{cwd}"')
        lines.append('                }')
        lines.append('            }')
        if panels:
            lines.append('            pane split_direction="horizontal" size="40%" {')
            for p in panels:
                lines.append(_panel_to_kdl(p, cwd, indent=16))
            lines.append('            }')
        lines.append('        }')

    lines.append('    }')
    return '\n'.join(lines)


def _panel_tmux_cmd(panel, cwd):
    """Return the command to send to a tmux pane for a panel."""
    app = panel.get("app", "")
    command = panel.get("command", "")

    if command:
        return command
    elif app == "shell" or (not app and not command):
        return ""
    elif app in APPS_CATALOG:
        info = APPS_CATALOG[app]
        cmd = info["cmd"]
        args = info["args"]
        if cmd and not shutil.which(cmd):
            brew = info.get("brew", "")
            msg = f"App not found: {app}"
            if brew:
                msg += f" — brew install {brew}"
            return f"echo '{msg}'"
        if app == "yazi":
            return f"{cmd} {cwd}"
        if args:
            return f"{cmd} {args}"
        return cmd
    else:
        return app


def _generate_tab_tmux(session, tab_index, tab, root=None):
    """Generate tmux commands for a tab.

    Uses relative navigation (-L, -R, -D) instead of absolute indices
    to be compatible with any base-index / pane-base-index setting.
    After each split-window, the active pane is the newly created one.
    """
    name = tab["name"]
    cwd = _resolve_dir(tab["dir"], root)
    layout = tab.get("layout", "default")
    panels = tab.get("panels", DEFAULT_PANELS)
    lines = []

    if tab_index == 0:
        lines.append(f'tmux new-session -d -s "{session}" -c "{cwd}" -x "$(tput cols)" -y "$(tput lines)"')
        lines.append(f'tmux rename-window -t "{session}" "{name}"')
    else:
        lines.append(f'tmux new-window -t "{session}" -n "{name}" -c "{cwd}"')

    if layout == "solo":
        pass

    elif layout == "wide":
        # Terminal on top, panels on bottom (30%)
        lines.append(f'tmux split-window -v -c "{cwd}" -p 30')
        if panels:
            cmd = _panel_tmux_cmd(panels[0], cwd)
            if cmd:
                lines.append(f'tmux send-keys "{cmd}" Enter')
            for p in panels[1:]:
                lines.append(f'tmux split-window -h -c "{cwd}"')
                cmd = _panel_tmux_cmd(p, cwd)
                if cmd:
                    lines.append(f'tmux send-keys "{cmd}" Enter')
        lines.append('tmux select-pane -t "{top}"')

    elif layout == "monitoring":
        # Terminal on the left (60%), stacked panels on the right (40%)
        lines.append(f'tmux split-window -h -c "{cwd}" -p 40')
        if panels:
            cmd = _panel_tmux_cmd(panels[0], cwd)
            if cmd:
                lines.append(f'tmux send-keys "{cmd}" Enter')
            for p in panels[1:]:
                lines.append(f'tmux split-window -v -c "{cwd}"')
                cmd = _panel_tmux_cmd(p, cwd)
                if cmd:
                    lines.append(f'tmux send-keys "{cmd}" Enter')
        lines.append('tmux select-pane -t "{left}"')

    else:
        # "default": terminal (60%) | stacked panels (40%)
        lines.append(f'tmux split-window -h -c "{cwd}" -p 40')
        if panels:
            cmd = _panel_tmux_cmd(panels[0], cwd)
            if cmd:
                lines.append(f'tmux send-keys "{cmd}" Enter')
            for p in panels[1:]:
                lines.append(f'tmux split-window -v -c "{cwd}"')
                cmd = _panel_tmux_cmd(p, cwd)
                if cmd:
                    lines.append(f'tmux send-keys "{cmd}" Enter')
        lines.append('tmux select-pane -t "{left}"')

    return '\n'.join(lines)


# ─── Commands ────────────────────────────────────────────────────────

def cmd_render(args):
    """Convert a TOML workspace file to a Zellij KDL layout."""
    toml_path = Path(args.file)
    if not toml_path.exists():
        print(f"File not found: {toml_path}", file=sys.stderr)
        sys.exit(1)

    with open(toml_path, 'rb') as f:
        config = tomllib.load(f)

    workspace = config.get("workspace", {})
    root = workspace.get("root", None)
    tabs = config.get("tabs", [])

    if not tabs:
        print("No tabs defined in workspace", file=sys.stderr)
        sys.exit(1)

    kdl_lines = ["layout {"]
    for tab in tabs:
        kdl_lines.append(_generate_tab_kdl(tab, root))
    kdl_lines.append("}")

    print('\n'.join(kdl_lines))


def cmd_render_tmux(args):
    """Convert a TOML workspace file to a tmux script."""
    toml_path = Path(args.file)
    if not toml_path.exists():
        print(f"File not found: {toml_path}", file=sys.stderr)
        sys.exit(1)

    with open(toml_path, 'rb') as f:
        config = tomllib.load(f)

    workspace = config.get("workspace", {})
    session = args.session or workspace.get("name", toml_path.stem)
    root = workspace.get("root", None)
    tabs = config.get("tabs", [])

    if not tabs:
        print("No tabs defined in workspace", file=sys.stderr)
        sys.exit(1)

    lines = [
        '#!/bin/bash',
        f'# Generated by sand-workspace-helper for tmux session "{session}"',
    ]
    for i, tab in enumerate(tabs):
        lines.append(_generate_tab_tmux(session, i, tab, root))

    # Remove session sidebar (simplified status-left, no session list)
    lines.append(f'tmux set-option -t "{session}" status-left "#[fg=#cccccc,bold] {session} #[default]│ "')
    lines.append(f'tmux set-option -t "{session}" status-right ""')

    # Select first window and attach
    lines.append(f'tmux select-window -t "{session}:{{start}}"')
    lines.append(f'exec tmux attach-session -t "{session}"')

    print('\n'.join(lines))


def cmd_validate(args):
    """Check the syntax and paths of a TOML workspace."""
    toml_path = Path(args.file)
    if not toml_path.exists():
        print(f"File not found: {toml_path}", file=sys.stderr)
        sys.exit(1)

    try:
        with open(toml_path, 'rb') as f:
            config = tomllib.load(f)
    except tomllib.TOMLDecodeError as e:
        print(f"TOML error: {e}", file=sys.stderr)
        sys.exit(1)

    workspace = config.get("workspace", {})
    root = workspace.get("root", None)
    tabs = config.get("tabs", [])
    errors = []
    warnings = []

    if not tabs:
        errors.append("No tabs defined")

    for i, tab in enumerate(tabs):
        if "name" not in tab:
            errors.append(f"Tab {i+1}: missing 'name' field")
        if "dir" not in tab:
            errors.append(f"Tab {i+1}: missing 'dir' field")
        else:
            d = _resolve_dir(tab["dir"], root)
            if not os.path.isdir(d):
                warnings.append(f"Tab '{tab.get('name', i+1)}': directory not found → {d}")

        layout = tab.get("layout", "default")
        if layout not in ("default", "wide", "solo", "monitoring"):
            errors.append(f"Tab '{tab.get('name', i+1)}': unknown layout '{layout}'")

        for j, panel in enumerate(tab.get("panels", [])):
            app = panel.get("app", "")
            cmd = panel.get("command", "")
            if app and app not in APPS_CATALOG and not cmd:
                warnings.append(f"Tab '{tab.get('name', i+1)}' panel {j+1}: app '{app}' not in catalog")

    if errors:
        for e in errors:
            print(f"ERROR: {e}", file=sys.stderr)
        sys.exit(1)

    if warnings:
        for w in warnings:
            print(f"WARNING: {w}", file=sys.stderr)

    print(f"Valid workspace: {len(tabs)} tab(s)")


def cmd_migrate(args):
    """Convert an old plain text workspace file to TOML."""
    old_path = Path(args.file)
    if not old_path.exists():
        print(f"File not found: {old_path}", file=sys.stderr)
        sys.exit(1)

    name = old_path.stem
    tabs = []

    with open(old_path) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split(None, 1)
            if len(parts) == 2:
                tabs.append({"name": parts[0], "dir": parts[1]})

    if not tabs:
        print("Empty or invalid file", file=sys.stderr)
        sys.exit(1)

    # Detect common root
    dirs_expanded = [_resolve_dir(t["dir"]) for t in tabs]
    common = os.path.commonpath(dirs_expanded) if len(dirs_expanded) > 1 else ""
    use_root = common and common != str(Path.home()) and len(common) > len(str(Path.home()))

    # Generate TOML
    lines = ['[workspace]']
    lines.append(f'name = "{name}"')
    if use_root:
        root_display = common.replace(str(Path.home()), "~")
        lines.append(f'root = "{root_display}"')
    lines.append('')

    for tab in tabs:
        lines.append('[[tabs]]')
        lines.append(f'name = "{tab["name"]}"')
        if use_root:
            d = _resolve_dir(tab["dir"])
            rel = os.path.relpath(d, common)
            lines.append(f'dir = "{rel}"')
        else:
            lines.append(f'dir = "{tab["dir"]}"')
        lines.append('')

    print('\n'.join(lines))


def cmd_catalog(args):
    """List TUI apps from the catalog with install status."""
    fmt = args.format if hasattr(args, 'format') else 'text'

    if fmt == 'fzf':
        for name, info in sorted(APPS_CATALOG.items()):
            cmd = info["cmd"]
            installed = not cmd or shutil.which(cmd)
            marker = "*" if installed else " "
            print(f"{marker} {name:<15} ({info['cat']})")
        return

    # Group by category
    by_cat = {}
    for name, info in sorted(APPS_CATALOG.items()):
        cat = info["cat"]
        by_cat.setdefault(cat, []).append((name, info))

    cat_order = [
        "git", "files", "monitoring", "docker", "kubernetes",
        "search/replace", "watch (rust)", "watch", "logs",
        "http", "database", "terminal",
    ]
    remaining = [c for c in by_cat if c not in cat_order]

    for cat in cat_order + remaining:
        if cat not in by_cat:
            continue
        print(f"\n  {cat.upper()}")
        for name, info in by_cat[cat]:
            cmd = info["cmd"]
            brew = info.get("brew", "")
            desc = info.get("desc", "")
            installed = not cmd or shutil.which(cmd)

            status = "\u2713" if installed else "\u2717"
            install_hint = ""
            if not installed:
                custom_install = info.get("install", "")
                if custom_install:
                    install_hint = f"  ({custom_install})"
                elif brew:
                    install_hint = f"  (brew install {brew})"

            print(f"    {status} {name:<15} {desc}{install_hint}")


def cmd_wizard(args):
    """Generate a workspace TOML interactively."""
    has_fzf = shutil.which("fzf") is not None

    def ask(prompt, default=""):
        """Ask for input with a default value."""
        suffix = f" [{default}]" if default else ""
        try:
            val = input(f"{prompt}{suffix}: ").strip()
        except (EOFError, KeyboardInterrupt):
            print()
            sys.exit(0)
        return val or default

    def ask_choice(prompt, choices, default=0):
        """Select from choices (fzf or numeric fallback)."""
        if has_fzf:
            choice_str = '\n'.join(choices)
            try:
                result = subprocess.run(
                    ['fzf', '--prompt', f'{prompt} > ', '--height=10', '--reverse'],
                    input=choice_str, capture_output=True, text=True
                )
                if result.returncode == 0:
                    return result.stdout.strip()
            except Exception:
                pass

        # Numeric fallback
        print(f"\n{prompt}:")
        for i, c in enumerate(choices):
            marker = "\u2192" if i == default else " "
            print(f"  {marker} {i+1}) {c}")
        try:
            num = input(f"Choice [1-{len(choices)}, default {default+1}]: ").strip()
        except (EOFError, KeyboardInterrupt):
            print()
            sys.exit(0)
        if not num:
            return choices[default]
        try:
            return choices[int(num) - 1]
        except (ValueError, IndexError):
            return choices[default]

    def ask_apps():
        """Select panel apps."""
        available = []
        for name, info in sorted(APPS_CATALOG.items()):
            cmd = info["cmd"]
            if not cmd or shutil.which(cmd):
                available.append(name)

        if has_fzf:
            items = '\n'.join(f"{n:<15} ({APPS_CATALOG[n]['cat']})" for n in available)
            try:
                result = subprocess.run(
                    ['fzf', '--multi', '--prompt', 'Apps > ',
                     '--header', 'Tab/Shift+Tab to select, Enter to confirm',
                     '--height=15', '--reverse'],
                    input=items, capture_output=True, text=True
                )
                if result.returncode == 0:
                    selected = []
                    for line in result.stdout.strip().split('\n'):
                        name = line.split()[0].strip()
                        if name in APPS_CATALOG:
                            selected.append(name)
                    return selected
            except Exception:
                pass

        # Numeric fallback
        print("\nAvailable apps:")
        for i, name in enumerate(available):
            cat = APPS_CATALOG[name]["cat"]
            print(f"  {i+1}) {name} ({cat})")
        try:
            nums = input("Numbers (e.g. 1 3 5, default: lazygit yazi): ").strip()
        except (EOFError, KeyboardInterrupt):
            print()
            sys.exit(0)
        if not nums:
            return ["lazygit", "yazi"]
        selected = []
        for n in nums.split():
            try:
                idx = int(n) - 1
                if 0 <= idx < len(available):
                    selected.append(available[idx])
            except ValueError:
                pass
        return selected or ["lazygit", "yazi"]

    # ── Step 1: Name ──
    print("\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557")
    print("\u2551   sand workspace new \u2014 wizard       \u2551")
    print("\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d")
    print()

    name = ask("Workspace name")
    if not name:
        print("Name required.", file=sys.stderr)
        sys.exit(1)

    # ── Step 2: Description ──
    description = ask("Description (optional, Enter to skip)")

    # ── Step 3: Root directory ──
    root = ask("Root directory (optional)")
    if root:
        root = root.replace("~", str(Path.home()))
        if not os.path.isdir(root):
            print(f"WARNING: directory not found \u2192 {root}", file=sys.stderr)

    # ── Step 4: Tabs ──
    tabs = []
    print("\n\u2500\u2500 Tabs \u2500\u2500")
    while True:
        tab_num = len(tabs) + 1
        print(f"\nTab {tab_num}:")
        tab_name = ask("  Tab name")
        if not tab_name:
            if tabs:
                break
            print("At least one tab required.")
            continue

        tab_dir = ask("  Directory")
        if not tab_dir:
            tab_dir = tab_name

        layout = ask_choice("  Layout", ["default", "wide", "solo", "monitoring"])

        print(f"\n  Panels for '{tab_name}':")
        apps = ask_apps()

        tab = {"name": tab_name, "dir": tab_dir, "layout": layout, "panels": apps}
        tabs.append(tab)

        try:
            more = input("\nAdd another tab? [y/N] ").strip().lower()
        except (EOFError, KeyboardInterrupt):
            print()
            break
        if more not in ('y', 'yes', 'o', 'oui'):
            break

    # ── Step 5: Generate TOML ──
    toml_lines = ['[workspace]']
    toml_lines.append(f'name = "{name}"')
    if description:
        toml_lines.append(f'description = "{description}"')
    if root:
        root_display = root.replace(str(Path.home()), "~")
        toml_lines.append(f'root = "{root_display}"')
    toml_lines.append('')

    for tab in tabs:
        toml_lines.append('[[tabs]]')
        toml_lines.append(f'name = "{tab["name"]}"')
        toml_lines.append(f'dir = "{tab["dir"]}"')
        if tab["layout"] != "default":
            toml_lines.append(f'layout = "{tab["layout"]}"')
        toml_lines.append('')
        for app in tab["panels"]:
            toml_lines.append('[[tabs.panels]]')
            toml_lines.append(f'app = "{app}"')
            toml_lines.append('')

    toml_content = '\n'.join(toml_lines)

    # ── Step 6: Summary and confirmation ──
    print("\n\u2500\u2500 Summary \u2500\u2500")
    print(toml_content)

    try:
        confirm = input("Write this workspace? [Y/n] ").strip().lower()
    except (EOFError, KeyboardInterrupt):
        print("\nCancelled.")
        sys.exit(0)

    if confirm in ('n', 'non', 'no'):
        print("Cancelled.")
        sys.exit(0)

    # Write file
    output_dir = args.output_dir if hasattr(args, 'output_dir') and args.output_dir else str(Path.home() / '.config' / 'sand' / 'workspaces')
    os.makedirs(output_dir, exist_ok=True)
    output_path = os.path.join(output_dir, f"{name}.toml")

    if os.path.exists(output_path):
        try:
            overwrite = input(f"File {output_path} already exists. Overwrite? [y/N] ").strip().lower()
        except (EOFError, KeyboardInterrupt):
            print("\nCancelled.")
            sys.exit(0)
        if overwrite not in ('y', 'yes', 'o', 'oui'):
            print("Cancelled.")
            sys.exit(0)

    with open(output_path, 'w') as f:
        f.write(toml_content)

    print(f"\n\u2713 Workspace created: {output_path}")
    print(f"  Launch with: sand {name}")


# ─── Main ────────────────────────────────────────────────────────────

def main():
    parser = argparse.ArgumentParser(
        prog='sand-workspace-helper',
        description='TOML parsing and KDL generation for sand workspaces',
    )
    sub = parser.add_subparsers(dest='command')

    # render
    render = sub.add_parser('render', help='Convert a .toml to a KDL layout')
    render.add_argument('file', help='Workspace .toml file')

    # render-tmux
    render_tmux = sub.add_parser('render-tmux', help='Convert a .toml to a tmux script')
    render_tmux.add_argument('file', help='Workspace .toml file')
    render_tmux.add_argument('--session', help='tmux session name')

    # validate
    validate = sub.add_parser('validate', help='Validate a workspace .toml')
    validate.add_argument('file', help='Workspace .toml file')

    # migrate
    migrate = sub.add_parser('migrate', help='Convert an old workspace to TOML')
    migrate.add_argument('file', help='Old workspace file (plain text)')

    # catalog
    catalog = sub.add_parser('catalog', help='List TUI apps')
    catalog.add_argument('--format', choices=['text', 'fzf'], default='text')

    # wizard
    wizard = sub.add_parser('wizard', help='Create a workspace interactively')
    wizard.add_argument('--output-dir', help='Output directory')

    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(0)

    commands = {
        'render': cmd_render,
        'render-tmux': cmd_render_tmux,
        'validate': cmd_validate,
        'migrate': cmd_migrate,
        'catalog': cmd_catalog,
        'wizard': cmd_wizard,
    }
    commands[args.command](args)


if __name__ == '__main__':
    main()
